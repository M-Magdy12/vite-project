create extension if not exists "pgcrypto";

create type conversation_status as enum (
  'open',
  'ai_handling',
  'escalated',
  'human_handling',
  'closed'
);

create type message_sender as enum (
  'customer',
  'ai',
  'agent'
);

create type ticket_status as enum (
  'open',
  'assigned',
  'resolved',
  'closed'
);


create table conversations (
  id uuid primary key default gen_random_uuid(),
  status conversation_status not null default 'open',
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create table messages (
  id uuid primary key default gen_random_uuid(),
  conversation_id uuid not null references conversations(id) on delete cascade,
  sender_type message_sender not null,
  content text not null,
  created_at timestamptz not null default now()
);

create table tickets (
  id uuid primary key default gen_random_uuid(),
  conversation_id uuid not null references conversations(id) on delete cascade,
  status ticket_status not null default 'open',
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create table knowledge_base (
  id uuid primary key default gen_random_uuid(),
  title text not null,
  content text not null,
  category text,
  created_at timestamptz not null default now()
);

create table profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  role text not null default 'agent',
  created_at timestamptz not null default now()
);

create or replace function public.set_updated_at()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;


create trigger set_conversations_updated_at
before update on conversations
for each row
execute function public.set_updated_at();

create trigger set_tickets_updated_at
before update on tickets
for each row
execute function public.set_updated_at();

create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id)
  values (new.id);
  return new;
end;
$$ language plpgsql security definer;


create trigger on_auth_user_created
after insert on auth.users
for each row
execute function public.handle_new_user();


create or replace function public.is_agent()
returns boolean as $$
  select exists (
    select 1
    from profiles
    where id = auth.uid()
    and role in ('agent', 'admin')
  );
$$ language sql stable;


alter table conversations enable row level security;
alter table messages enable row level security;
alter table tickets enable row level security;
alter table knowledge_base enable row level security;
alter table profiles enable row level security;

create policy "Agents can read conversations"
on conversations
for select
using (public.is_agent());

create policy "Agents can update conversations"
on conversations
for update
using (public.is_agent());


create policy "Agents can read messages"
on messages
for select
using (public.is_agent());

create policy "Agents can insert messages"
on messages
for insert
with check (public.is_agent());


create policy "Agents can manage tickets"
on tickets
for all
using (public.is_agent())
with check (public.is_agent());

create policy "Agents can read knowledge base"
on knowledge_base
for select
using (public.is_agent());


create policy "Users can read own profile"
on profiles
for select
using (id = auth.uid());
